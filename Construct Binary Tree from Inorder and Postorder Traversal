/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:

    TreeNode *buildTree(vector<int> &inorder, vector<int> &postorder) {
  	// Start typing your C/C++ solution below
		// DO NOT write int main() function
		if (inorder.empty() || postorder.empty()) {
			return NULL;
		}

		TreeNode* ptree;
		int inLen = inorder.size();
		int postLen = postorder.size();
		if (inLen == 1 && postLen == 1)  {
			ptree = new TreeNode(inorder[0]);
		}
		else{
			//set the root
			ptree = new TreeNode(*(postorder.end()-1));
			vector<int> leftInNodes;
			vector<int> rightInNodes;
			vector<int> leftPostNodes;
			vector<int> rightPostNodes;
			vector<int>::iterator tempitor = inorder.begin() ;

			for (tempitor= inorder.begin(); tempitor!=inorder.end(); tempitor++) {

				if (*tempitor == *(postorder.end()-1)) {

					copy(inorder.begin(), tempitor, back_inserter(leftInNodes));
					copy(tempitor+1, inorder.end(), back_inserter(rightInNodes));
					std::vector<int>::iterator leftPost = postorder.begin();
					copy(leftPost, leftPost+leftInNodes.size(), back_inserter(leftPostNodes));
					copy(leftPost+leftInNodes.size(), postorder.end()-1,back_inserter(rightPostNodes));
					
					ptree->left = buildTree(leftInNodes, leftPostNodes);
                	ptree->right = buildTree(rightInNodes, rightPostNodes);

				}

			}//end for
		}//end else
		return ptree;
	}
};
